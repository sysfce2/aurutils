#!/bin/bash
# aur-query - interface with AurJson
[[ -v AUR_DEBUG ]] && set -o xtrace
argv0=query
AUR_LOCATION=${AUR_LOCATION:-https://aur.archlinux.org}
AUR_QUERY_PARALLEL=${AUR_QUERY_PARALLEL:-0}
AUR_QUERY_PARALLEL_MAX=${AUR_QUERY_PARALLEL_MAX:-15}
AUR_QUERY_RPC=${AUR_QUERY_RPC:-$AUR_LOCATION/rpc}
AUR_QUERY_RPC_POST=${AUR_QUERY_RPC_POST:-1}
AUR_QUERY_RPC_SPLITNO=${AUR_QUERY_RPC_SPLITNO:-150}
AUR_QUERY_RPC_VERSION=${AUR_QUERY_RPC_VERSION:-5}
PS4='+(${BASH_SOURCE}:${LINENO}):${FUNCNAME[0]:+${FUNCNAME[0]}(): }'

# default arguments
curl_args=(-A aurutils -fgLsSq --tcp-fastopen)

# Filters for generating curl configuration
rpc_info() {
    local rpc_url="$AUR_QUERY_RPC?v=$AUR_QUERY_RPC_VERSION&type=info"
    local splitno="$AUR_QUERY_RPC_SPLITNO"

    # Write opening and closing quotes with \x22 (hexadecimal)
    awk -v rpc="$rpc_url" -v splitno="$splitno" '{
        if (NR == 1)
            printf "url \x22%s&arg[]=%s", rpc, $0
        else if (NR % splitno == 0)
            printf "\x22\nurl \x22%s&arg[]=%s", rpc, $0
        else if (NR > 1)
            printf "&arg[]=%s", $0
    } END {
        if (NR != 0)
            printf "\x22\n"
    }'
}

# POST requests are useful for info-type requests to circumvent limits on the
# URL length with GET requests. The difference is that all data is now included
# in the message body, instead of in the URI.
rpc_info_post() {
    # TODO: This could potentially be split into multiple url sections for use
    # with curl --parallel (benchmarks?)
    printf 'url "%s"\n' "$AUR_QUERY_RPC"
    printf 'data "v=%s"\n' "$AUR_QUERY_RPC_VERSION"
    printf 'data "type=info"\n'

    while IFS= read -r pkg; do
        printf 'data-urlencode "arg[]=%s"\n' "$pkg"
    done
}

# Search-type requests can only contain one package argument, and GET requests
# are sufficient for this.
rpc_search() {
    local rpc_url="$AUR_QUERY_RPC?v=$AUR_QUERY_RPC_VERSION&type=search&by=$1&arg"

    while IFS= read -r term; do
        printf 'url "%s=%s"\n' "$rpc_url" "$term"
    done
}

trap_exit() {
    if [[ ! -v AUR_DEBUG ]]; then
        rm -rf -- "$tmp"
    else
        printf >&2 'AUR_DEBUG: %s: temporary files at %s\n' "$argv0" "$tmp"
    fi
}

usage() {
    printf 'usage: %s [-t [info|search] ] [-b by] <package...>\n' "$argv0" >&2
    exit 1
}

source /usr/share/makepkg/util/parseopts.sh

opt_short='b:t:'
opt_long=('by:' 'type:')
opt_hidden=('dump-options')

if ! parseopts "$opt_short" "${opt_long[@]}" "${opt_hidden[@]}" -- "$@"; then
    usage
fi
set -- "${OPTRET[@]}"

unset arg_by arg_type
while true; do
    case "$1" in
        -b|--by)
            shift; arg_by=$1 ;;
        -t|--type)
            shift; arg_type=$1 ;;
        --dump-options)
            printf -- '--%s\n' "${opt_long[@]}" ${AUR_DEBUG+"${opt_hidden[@]}"}
            printf -- '%s' "${opt_short}" | sed 's/.:\?/-&\n/g'
            exit ;;
        --) shift; break ;;
    esac
    shift
done

# shellcheck disable=SC2174
mkdir -pm 0700 "${TMPDIR:-/tmp}/aurutils-$UID"
tmp=$(mktemp -d --tmpdir "aurutils-$UID/$argv0.XXXXXXXX") || exit
trap 'trap_exit' EXIT

# Single hyphen to denote input taken from stdin
stdin=0
if (( $# == 1 )) && [[ $1 == "-" || $1 == "/dev/stdin" ]]; then
    stdin=1
fi

if (( ! $# )); then
    usage
fi

# set filters
if [[ $arg_type == "search" ]]; then
    curl_config() { jq -R -r '@uri' | rpc_search "${arg_by:-name-desc}"; }

elif [[ $arg_type == "info" ]] && (( AUR_QUERY_RPC_POST )); then
    curl_config() { rpc_info_post; }  # URI encoding is handled by curl --data-urlencode

elif [[ $arg_type == "info" ]]; then
    curl_config() { jq -R -r '@uri' | rpc_info; }
fi

# main pipeline
if (( stdin )); then
    tee # noop
else
    printf '%s\n' "$@"
fi | curl_config > "$tmp"/config

# exit cleanly on empty input (#706)
if [[ ! -s $tmp/config ]]; then
    exit
fi

# support parallel transfers (curl >7.66.0)
if (( AUR_QUERY_PARALLEL )); then
    # curl 7.77.0: tool_operate: don't discard failed parallel transfer result
    curl_args+=(--parallel --parallel-max "$AUR_QUERY_PARALLEL_MAX")
fi
curl "${curl_args[@]}" -K "$tmp"/config

# vim: set et sw=4 sts=4 ft=sh:
